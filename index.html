<html>
    <head>
        <style>
            .dataOutput{
                border-collapse: separate;
                border: solid 1px #000000;
                margin-bottom: 20px;
                width: 800px;
                border-spacing: 0;
            }

            #tblConsolIndv td{
                padding: 10px;
            }

            .rowClusterInfo td{
                padding: 10px;
            }

            .rowHeader, .rowClusterInfo{
                border: solid 1px #000000;
            }

            .cellHeader{
                padding: 10px;
            }

            .cellData{
                padding: 10px;
            }

            .rowConsol{
                border: solid 1px #000000;
            }

            .cellConsol{
                padding: 10px;
            }
            
            .outContainer {
                margin-bottom: 20px;
            }

            .added{
                border: solid 3px #00ff00;
            }

            tr.added td
            {
                border: solid #00ff00;
                border-width: 3px 0px;
            }

            tr.added :first-child
            {
                border-left-width: 3px;
            }

            tr.added :last-child
            {
                border-right-width: 3px;
            }

            .removed{
                border: solid 3px #ff0000;
            }

            tr.removed td
            {
                border: solid #ff0000;
                border-width: 3px 0px;
            }

            tr.removed :first-child
            {
                border-left-width: 3px;
            }

            tr.removed :last-child
            {
                border-right-width: 3px;
            }

            #outSteps{
                margin-bottom: 20px;
                float: left;
                cursor: pointer;
            }

            .scenarioStep{
                float: left;
                padding: 20px;
                border: solid 1px #000000;
                margin: 6px 15px 0 0;
                background-color: #ffffff;
            }

            .scenarioStepPointer{
                float: left;
                padding: 20px 0 20px 0;
                margin: 6px 15px 0px 0px;
            }

            #outSteps :last-child{
                margin-right: 0;
            }

            #outSteps :first-child{
                margin-left: 0;
            }

            .selectedStep{
                background-color: #fdff8c;
            }

            .stepGroup{
                float: left;
                border: solid 1px #000000;
                padding: 5px;
                background-color: #efefef;
                margin: 0px 15px 0px 0px;
            }

            .stepgroup .scenarioStep, .stepgroup .scenarioStepPointer{
                margin-top: 0;
            }

             .objArray, .objArray tr{
                width: auto;
                border-width: 0;
                border: none;
                margin: 0;
                padding: 0;
                white-space: nowrap;
            }

            .objArray tr td{
                border-width: 0;
                border: none;
                padding: 0 2px 0 2px;
                white-space: nowrap;
            }

            .objArray .rowHeader{
                display: none;
            }
        </style>

        <script src="https://code.jquery.com/jquery-3.6.1.min.js" integrity="sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ=" crossorigin="anonymous"></script>

        <script lang="javascript">
            var showDeltas = true;
            var scenarios = [];
            var defaultScenario = 0;

            var colors = [
                'ffdbd9',
                'ffeed9',
                'feffd9',
                'd9ffda',
                'd9feff',
                'dbd9ff',
                'f2d9ff',
                'ffd9f7',
                'ffd9da'
            ];

            var defaultConsolidationSortKeys = [
                { key: 'object_type', direction: 'asc'},
                { key: 'last_updated', direction: 'desc'} 
            ];

            $(document).ready(function(){
                var qsScenario = new URLSearchParams(window.location.search).get('scenario');

                if(qsScenario !== undefined && qsScenario != null)
                {
                    for(var idx in scenarios)
                    {
                        if(scenarios[idx].id == qsScenario)
                        {
                            currentscenarioIdx = idx;
                            currentScenario = scenarios[currentscenarioIdx];
                        }
                    }
                }

                uiRenderCurrentSelections();
            });
        </script>
<!-- ########################################################################################################################
#######
####### All Scenario Information goes In this section
#######
########################################################################################################################-->
        <!-- <script src="Scenario-Debug.js"></script> -->
        <script src="Scenario-IDGeneration.js"></script>
        <script src="Scenario-DataUnification.js"></script>
        <script src="Scenario-JourneyHistory.js"></script>
        <script src="Scenario-MultipleLeads.js"></script>
        <script src="Scenario-SharedFamilyEmail.js"></script>
        <script src="Scenario-NameChange.js"></script>
        <script src="Scenario-MultipleContacts.js"></script>
        <script src="Scenario-EmailChange.js"></script>

        <!--
        
        <script src="Scenario-MultipleEmails.js"></script>
        
        -->

<!-- ########################################################################################################################
########################################################################################################################-->
    </head>
    <body>
        <div style="margin-bottom: 20px;">
            <select id="selScenario">
                <option></option>
            </select>
            <select id="selDeltaView" style="display: none;">
                <option value="merged" selected="true">Merged</option>
                <option value="start">Start</option>
                <option value="finish">Finish</option>
            </select>
            <select id="selStepStart" style="display: none;"></select>
        </div>
        <div id="outSteps"></div>
        <h1 style="clear: both;">Raw Individuals</h1>
        <div class="outContainer" id="outRawData"></div>
        <h1 style="display: none;">Match Key Sorted Individuals</h1>
        <div style="display: none;" class="outContainer" id="outSortedData"></div>
        <h1>Clustered Individuals</h1>
        <div class="outContainer" id="outGroupedData"></div>
        <h1>Consolidated Individuals</h1>
        <div class="outContainer" id="outConsolidatedData"></div>
    </body>
    <script lang="javascript">
        var currentscenarioIdx = defaultScenario;
        var currentScenario = scenarios[currentscenarioIdx];
        var currentScenarioSelectedStep = 0;
        var currentView = 'merged';

        var scenarioDD = $('#selScenario');
        
        for(var idx in scenarios)
        {
            var curScenario = scenarios[idx];
            var curTitlte = curScenario.title ?? idx;

            var option = $('<option value="' + idx + '">' + curTitlte + '</option>');
            scenarioDD.append(option);

            scenarioDD.val(currentscenarioIdx);
        }
        
        scenarioDD.change(function()
        {
            currentScenario = scenarios[this.value];
            currentscenarioIdx = this.value;
            currentScenarioSelectedStep = 0;
            currentView = 'merged';

            uiRenderCurrentSelections();
        });

        var viewDD = $('#selDeltaView');

        viewDD.change(function(){
            currentView = this.value;

            uiRenderCurrentSelections();
        });

        var stepDD = $('#selStepStart');

        stepDD.change(function(){
            currentScenarioSelectedStep = Number.parseInt(this.value);

            uiRenderCurrentSelections();
        });

        function uiRenderCurrentSelections()
        {
            clear();

            if(currentScenario !== undefined && currentScenario !== null)
            {
                var tmpCurScenarioStartStep = currentScenarioSelectedStep
                scenarioDD.val(currentscenarioIdx);

                // update the QS values
                var newurl = window.location.protocol + "//" + window.location.host + window.location.pathname;

                if(currentScenario.id != undefined && currentScenario.id != null)
                {
                    var outQS = '?scenario=' + currentScenario.id;
                    newurl = newurl + outQS;
                }

                window.history.pushState({path: newurl}, '', newurl);

                // if there is only one step
                if(currentScenario.steps.length == 1)
                {
                    tmpCurScenarioStartStep = 0;
                }
                // if it is the last step
                else if(tmpCurScenarioStartStep == (currentScenario.steps.length - 1))
                {
                    tmpCurScenarioStartStep--;
                }
                else if(currentView == 'finish')
                {
                    tmpCurScenarioStartStep--;
                }

                viewDD.val(currentView);

                populateStepDDByScenario(currentScenario);
                outputStepUIScenario(currentScenario);
                executePipeline(currentScenario, tmpCurScenarioStartStep, tmpCurScenarioStartStep + 1, currentView /*'merged' 'start' 'finish'*/);
            }
            else
            {
                var newurl = window.location.protocol + "//" + window.location.host + window.location.pathname;
                window.history.pushState({path: newurl}, '', newurl);
            }
        }

        function populateStepDDByScenario(scenario)
        {
            if(scenario.steps.length <= 1)
            {
                stepDD.hide();
            }
            else
            {
                //stepDD.show();

                for(var i = 0; i < scenario.steps.length; i++)
                {
                    var curOption = $('<option value="' + i + '">' + scenario.steps[i].title + '</option>');
                    stepDD.append(curOption);
                }

                stepDD.val(currentScenarioSelectedStep);
            }
        }

        function outputStepUIScenario(scenario)
        {
            var container = $('#outSteps');
            var outStepGroupDiv = $('<div class="stepGroup"></div>');
            var isFirstSelected = true;
            

            for(var i = 0; i < scenario.steps.length; i++)
            {
                var isCurrentSelectedStep = false;

                if(i == currentScenarioSelectedStep)
                {
                    isCurrentSelectedStep = true;
                }

                var addPointerToGroup = false;

                if(isCurrentSelectedStep && (currentView == 'start' || currentView == 'merged'))
                {
                    addPointerToGroup = true;
                }

                if(i == currentScenarioSelectedStep - 1 && currentView == 'finish')
                {
                    addPointerToGroup = true;
                }

                var outStepDiv = $('<div class="scenarioStep">' + scenario.steps[i].title + '</div>');
                var isInCurrentGroup = false;

                var outPointer = $('<div class="scenarioStepPointer">-></div>');

                (function(index){
                        outPointer.click
                        (
                                function()
                                { 
                                    currentScenarioSelectedStep = index;
                                    currentView = "merged";
                                    uiRenderCurrentSelections();
                                }
                        )
                    }
                    )(i);


                if(isCurrentSelectedStep)
                {
                    isInCurrentGroup = true;
                }

                if((currentView == 'start' || currentView == 'merged' ) && i == currentScenarioSelectedStep + 1)
                {
                    isInCurrentGroup = true;
                }

                if(currentView == 'finish' && i == currentScenarioSelectedStep - 1)
                {
                    isInCurrentGroup = true;
                }

                (function(index){
                    outStepDiv.click(function(){ 
                        currentScenarioSelectedStep = index;

                        if(index == currentScenario.steps.length - 1)
                        {
                            currentView = 'finish';
                        }
                        else if(index == 0)
                        {
                            currentView = 'start';
                        }
                        else
                        {
                            currentView = currentView == 'start' ? 'finish' : 'start';
                        }

                        uiRenderCurrentSelections();
                     })
                })(i);

                if(isInCurrentGroup)
                {
                    if(isFirstSelected)
                    {
                        isFirstSelected = false;
                        container.append(outStepGroupDiv);
                    }

                    outStepGroupDiv.append(outStepDiv);

                    if(isCurrentSelectedStep || currentView == 'merged')
                    {
                        outStepDiv.addClass('selectedStep');
                    }
                }
                else
                {
                    container.append(outStepDiv);
                }

                if(i < scenario.steps.length - 1)
                {
                    if(isInCurrentGroup && addPointerToGroup)
                    {
                        outStepGroupDiv.append(outPointer);
                    }
                    else
                    {
                        container.append(outPointer);
                    }
                }
            }
        }

        function clear(){
            var clearIDs = ['outRawData', 'outSortedData', 'outGroupedData', 'outConsolidatedData', 'outSteps', 'selStepStart'];

            for(var idx in clearIDs)
            {
                $('#' + clearIDs[idx]).empty();
            }

            $('#selStepStart').hide();
        }

        function deepClone(obj){
            return JSON.parse(JSON.stringify(obj));
        }

        function dataCalculateDeltas(objGroupA, objGroupB, compareKey)
        {
            var sortConfig = [{ key: compareKey, direction: 'asc'}]

            dataSortObjArrayByKeys(objGroupA, sortConfig);
            dataSortObjArrayByKeys(objGroupB, sortConfig);

            var idxB = 0;
            var isFirstB = true;

            for(var idxA in objGroupA)
            {
                var objA = objGroupA[idxA];
                var curValA = objA[compareKey];

                var objMatched = false;

                if(idxB < objGroupB.length)
                {
                    var objB = objGroupB[idxB];
                    var curValB = objB[compareKey];

                    while(idxB < objGroupB.length && curValA >= curValB)
                    {
                        if(curValA == curValB)
                        {
                            objA.delta = 'unchanged';
                            objB.delta = 'unchanged';

                            objMatched = true;
                        }
                        else{
                            objB.delta = 'added';
                        }

                        idxB++;

                        if(idxB < objGroupB.length)
                        {
                            objB = objGroupB[idxB];
                            curValB = objB[compareKey];
                        }
                    }
                }
                
                if(!objMatched)
                {
                    objA.delta = 'removed';
                }
            }

            while(idxB < objGroupB.length)
            {
                var curObjB = objGroupB[idxB];

                curObjB.delta = 'added';

                idxB++;
            }
        }

        function hashString(str, seed = 0) {
            let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
            for (let i = 0, ch; i < str.length; i++) {
                ch = str.charCodeAt(i);
                h1 = Math.imul(h1 ^ ch, 2654435761);
                h2 = Math.imul(h2 ^ ch, 1597334677);
            }
            h1 = Math.imul(h1 ^ (h1>>>16), 2246822507) ^ Math.imul(h2 ^ (h2>>>13), 3266489909);
            h2 = Math.imul(h2 ^ (h2>>>16), 2246822507) ^ Math.imul(h1 ^ (h1>>>13), 3266489909);
            return 4294967296 * (2097151 & h2) + (h1>>>0);
        };

        function crteateDataFromScenarioRawData(data, irMatchKey, consolidationMode, consolidationSortKeys, uidMode){
            // get the raw data
            var stepRawData = deepClone(data);

            // get data sorted by match key
            var stepSortedData = deepClone(data);

            stepSortedData.sort(function(a,b){
                var valA = a[irMatchKey];
                var valB = b[irMatchKey];

                if(valA>valB)
                {
                    return 1;
                }

                if(valA<valB)
                {
                    return -1;
                }

                    return 0;
            });

            // cluster the data (IR)
            // break data apart by match key
            var clusters = [];
            var isFirst = true;
            var prevValue;
            var curCluster = {
                matchValue: null,
                clusterId: null,
                individuals: new Array()
            };
            
            clusters.push(curCluster);

            for(var idx in stepSortedData)
            {
                if(isFirst)
                {
                    prevValue = stepSortedData[idx][irMatchKey];
                    isFirst = false;
                }

                var curRow = deepClone(stepSortedData[idx]);
                var curValue = curRow[irMatchKey];
                var curClusterId = hashString(curValue);

                if(curValue !== prevValue)
                {
                    curCluster = {
                        matchValue: null,
                        clusterId: null,
                        individuals: new Array()
                    };
                    clusters.push(curCluster);
                }

                curCluster.matchValue = curValue;
                curCluster.clusterId = curClusterId;
                curCluster.individuals.push(curRow);

                var prevValue = curValue;
            }

            var consolidatedIndividuals = new Array();

            for(var idx in clusters)
            {
                var clst = clusters[idx];
                var curConsIndv = dataConsolidateAttributes(clst.individuals, consolidationMode, consolidationSortKeys);
                curConsIndv.clusterId = clst.clusterId;

                clst.topRankId = curConsIndv.id;

                if(uidMode == 'Cluster')
                {
                    clst.UID = clst.clusterId;
                    curConsIndv.UID = clst.clusterId;
                }
                else if(uidMode == 'Member')
                {
                    clst.UID = curConsIndv.id;
                    curConsIndv.UID = curConsIndv.id;
                }

                consolidatedIndividuals.push(curConsIndv);
            }

            var output = {
                dataRaw: stepRawData,
                dataMatchSorted: stepSortedData,
                dataClusters: clusters,
                dataConsolidatedIndv: consolidatedIndividuals
            };

            return output;
        }

        function outputTablesForEachDataType(dataObj)
        {
            // Display the raw data
            outputTableFromObjectArray(dataObj.dataRaw, 'outRawData');
            outputTableFromObjectArray(dataObj.dataConsolidatedIndv, 'outConsolidatedData', true, false);

            for(var idx in dataObj.dataClusters)
            {
                var curCluster = dataObj.dataClusters[idx];
                var table = outputTableFromObjectArray(curCluster.individuals, 'outGroupedData', true, true);

                var clusterRow = $('<tr class="rowClusterInfo"><td colspan="100"><b>Unified Individual ID:</b> ' + curCluster.UID + ', <b>Top Rank ID:</b> ' + curCluster.topRankId + ', <b>Cluster ID:</b> ' + curCluster.clusterId + ', <b>Match Value:</b> ' + curCluster.matchValue + ', <b>Delta:</b> ' + curCluster.delta + '</td></tr>');
                table.prepend(clusterRow);

                if(curCluster.delta == 'removed')
                {
                    table.addClass('removed');
                }

                if(curCluster.delta == 'added')
                {
                    table.addClass('added');
                }
            }
        }

        function dataConsolidateAttributes(arrayData, consolidationMode, consolidationSortKeys)
        {
            dataSortObjArrayByKeys(arrayData, consolidationSortKeys);
            var masterObj = getCompleteProperties(arrayData);
            var retObj = { colorMap: {}, isUnifiedIndv: true };

            // loop through each property
            for(var masterKey in masterObj)
            {
                retObj[masterKey] = null;

                if(consolidationMode == 'Consolidate')
                {
                    // find the first available value
                    for(var idx in arrayData)
                    {
                        var curRow = arrayData[idx];
                        var curVal = curRow[masterKey];
                        var curColor = curRow.color;

                        if(curVal != undefined && curVal !=null)
                        {
                            retObj[masterKey] = curVal;
                            retObj.colorMap[masterKey] = curColor;
                            break;
                        }
                    }
                }
                else if(consolidationMode == 'PickAWinner'){
                    retObj[masterKey] = arrayData[0][masterKey];
                }
            }

            return retObj;
        }

        function dataSortObjArrayByKeys(objArray, sortKeys)
        {
            objArray.sort(function(a, b)
            {
                var retSort = 0;

                for(var idx in sortKeys)
                {
                    var sortKey = sortKeys[idx].key;
                    var sortDir = sortKeys[idx].direction;

                    var curSortValA = a[sortKey];
                    var curSortValB = b[sortKey];

                    if(curSortValA < curSortValB)
                    {
                        retSort = -1;

                        if(sortDir == 'desc')
                        {
                            retSort = retSort * -1;
                        }

                        break;
                    }

                    if(curSortValA > curSortValB)
                    {
                        retSort = 1;

                        if(sortDir == 'desc')
                        {
                            retSort = retSort * -1;
                        }

                        break;
                    }
                }

                return retSort;
            });
        }   

        function outputTableFromObjectArray(arrayData, outContainerID, append, showRank)
        {
            var outTable = $('<table class="dataOutput"></table>');
            var excludedKeys = [ 'color', 'colorMap', 'isUnifiedIndv' ];

            if(!showDeltas)
            {
                excludedKeys.push('delta');
            }

            var data = arrayData;
            var masterObj = getCompleteProperties(arrayData);

            if(outContainerID != null)
            {
                var outContainer = $('#' + outContainerID);

                if(!append)
                {
                    outContainer.empty();
                }

                outContainer.append(outTable);
            }

            // collect all properties
            for(var i = 0; i < data.length; i++)
            {
                var curObj = data[i];


                for(var key in curObj)
                {
                    if(masterObj[key] === undefined || masterObj[key] == null)
                    {
                        masterObj[key] = [];
                    }

                    var curVal = curObj[key];
                    var curDataColor = curObj.color;

                    if(curVal !== undefined && curVal !== null)
                    {
                        masterObj[key].push({ color: curDataColor, val: curVal });
                    }
                }
            }

            // output the headers
            var rowHeader = $('<tr class="rowHeader"></tr>');// outputTable.append('<th></th>');
            outTable.append(rowHeader);

            if(showRank)
            {
                rowHeader.append('<th class="cellHeader">Rank</th>');
            }

            for(var masterKey in masterObj)
            {
                if(!excludedKeys.includes(masterKey))
                {
                    var col = rowHeader.append('<th class="cellHeader">' + masterKey + '</th>');
                }
            }

            // output data
            for(var dataKey in data)
            {
                var curData = data[dataKey];
                var curDataColor = curData.color;
                var rank = dataKey;

                var row = $('<tr></tr>');

                if(curData.isUnifiedIndv)
                {
                    row.addClass('rowConsol');
                    rank = '';
                }

                if(curData.delta == 'added')
                {
                    row.addClass('added');
                }

                if(curData.delta == 'removed')
                {
                    row.addClass('removed');
                }

                outTable.append(row);

                if(showRank)
                {
                    row.append('<td class="cellData" style="background-color: #' + curDataColor + '">' + rank + '</td>');
                }

                for(var masterKey in masterObj)
                {
                    var tmpCellColor = curDataColor;

                    if(!excludedKeys.includes(masterKey))
                    {
                        var curVal = curData[masterKey];

                        if(curVal === undefined)
                        {
                            tmpCellColor = 'efefef';
                        }

                        if(curData.colorMap)
                        {
                            tmpCellColor = curData.colorMap[masterKey] ?? tmpCellColor;
                        }

                        var outDataCell = $('<td class="cellData" style="background-color: #' + tmpCellColor + '"></td>');
                        row.append(outDataCell);


                        if(Array.isArray(curVal))
                        {
                            if(1==1){
                                var outSubData = outputTableFromObjectArray(curVal, null, false, false);
                                outSubData.addClass('objArray');
                                outDataCell.append(outSubData);
                            }
                            else{
                                var list = $('<ul class="valArray"></ul>');
                                outDataCell.append(list);


                                for(var idx in curVal)
                                {
                                    var curItem = curVal[idx]

                                    if(typeof curItem === 'object')
                                    {
                                        curItem = JSON.stringify(curItem);
                                    }

                                    list.append('<li>' + curItem + '</li>');
                                }
                            }

                        }
                        else
                        {
                            var col = outDataCell.append(curVal ? curVal:'undefined');
                        }
                    }
                }
            }

            return outTable;
        }

        function getCompleteProperties(arrayData)
        {
            var masterObj = {};
            data = arrayData;

            // collect all properties
            for(var i = 0; i < data.length; i++)
            {
                var curObj = data[i];

                for(var key in curObj)
                {
                    if(masterObj[key] === undefined)
                    {
                        masterObj[key] = null;
                    }
                }
            }

            return masterObj;
        }

        function executePipeline(scenario, startStepIdx, finishStepIdx, outputStep)
        {
            var matchKey = scenario.irMatchKey;
            var consolidationMode = scenario.consolidationMode;
            var consolidationSortKeys = scenario.consolidationSortKeys ?? defaultConsolidationSortKeys;
            var inputDataStart = scenario.steps[startStepIdx].data;
            var uidMode = scenario.uidMode ?? 'Member';

            var idKeyRaw = 'id';
            var idKeyClust = 'UID';
            var idKeyConsIndv = 'UID';

            // compute all the data - cluster data, consolidate data
            var computedDataStart = crteateDataFromScenarioRawData(inputDataStart, matchKey, consolidationMode, consolidationSortKeys, uidMode);
            var finalData = computedDataStart;

            if(scenario.steps.length > 1)
            {
                var inputDataFinish = scenario.steps[finishStepIdx].data;
                var computedDataFinish = crteateDataFromScenarioRawData(inputDataFinish, matchKey, consolidationMode, consolidationSortKeys, uidMode);

                dataCalculateDeltas(computedDataStart.dataRaw, computedDataFinish.dataRaw, idKeyRaw);
                dataCalculateDeltas(computedDataStart.dataClusters, computedDataFinish.dataClusters, idKeyClust)
                dataCalculateDeltas(computedDataStart.dataConsolidatedIndv, computedDataFinish.dataConsolidatedIndv, idKeyConsIndv);

                // calculate deltas for each individual cluster
                for(var idxA in computedDataStart.dataClusters)
                {
                    var curClusterA = computedDataStart.dataClusters[idxA];
                    var curClusterAId = curClusterA[idKeyClust];
                    var clusterAMatched = false;

                    for(var idxB in computedDataFinish.dataClusters)
                    {
                        var curClusterB = computedDataFinish.dataClusters[idxB];
                        var curClusterBId = curClusterB[idKeyClust];

                        if(curClusterAId == curClusterBId)
                        {
                            clusterAMatched = true;
                            dataCalculateDeltas(curClusterA.individuals, curClusterB.individuals, idKeyRaw);
                            clusterAMatched = true;
                        }
                    }

                    if(!clusterAMatched)
                    {
                        for(var removedIdx in curClusterA.individuals)
                        {
                            curClusterA.individuals[removedIdx].delta = 'removed';
                        }
                    }
                }

                for(var idx in computedDataFinish.dataClusters)
                {
                    var curClusterFinished = computedDataFinish.dataClusters[idx];

                    if(curClusterFinished.delta == 'added')
                    {
                        for(var addIdx in curClusterFinished.individuals)
                        {
                            curClusterFinished.individuals[addIdx].delta = 'added';
                        } 
                    }
                }

                finalData = computedDataFinish;

                if(outputStep == 'start')
                {
                    finalData = computedDataStart;
                }

                if(outputStep == 'merged')
                {
                    finalData = dataCombineDataIterations(computedDataStart, computedDataFinish, idKeyRaw, idKeyClust, idKeyConsIndv);
                }
            }

            outputTablesForEachDataType(finalData);
        }

        function dataCombineDataIterations(dataIterationOne, dataIterationTwo, idKeyRawData, idKeyClusterData, idKeyConsolidatedIndividuals, uidMode)
        {
            var output = {
                dataRaw: deepClone(dataIterationOne.dataRaw),
                dataMatchSorted: deepClone(dataIterationOne.dataMatchSorted),
                dataClusters: deepClone(dataIterationOne.dataClusters),
                dataConsolidatedIndv: deepClone(dataIterationOne.dataConsolidatedIndv)
            };

            output.dataRaw = output.dataRaw.concat(deepClone(dataIterationTwo.dataRaw));
            output.dataMatchSorted = output.dataMatchSorted.concat(deepClone(dataIterationTwo.dataMatchSorted));
            output.dataConsolidatedIndv = output.dataConsolidatedIndv.concat(deepClone(dataIterationTwo.dataConsolidatedIndv));

            output.dataClusters = output.dataClusters.concat(deepClone(dataIterationTwo.dataClusters));

            var tmpClusters = deepClone(dataIterationOne.dataClusters);
            tmpClusters = tmpClusters.concat(deepClone(dataIterationTwo.dataClusters));

            dataSortObjArrayByKeys(tmpClusters, [{key: idKeyClusterData, direction: 'asc'}]);

            // combine any duplicate clusters
            var tmpCombinedClusters = new Array();
            var idx = 0;
            var nextClusterIdx = idx + 1;

            while(idx < tmpClusters.length)
            {
                var curCluster = tmpClusters[idx];
                var nextCluster = tmpClusters[nextClusterIdx];
                var tmpClusterACopy = deepClone(curCluster);
                tmpCombinedClusters.push(tmpClusterACopy);

                if(nextCluster === undefined)
                {
                    
                }
                else if(curCluster[idKeyClusterData] == nextCluster[idKeyClusterData])
                {
                    while(nextCluster !== undefined && curCluster[idKeyClusterData] == nextCluster[idKeyClusterData])
                    {
                        var tmpClusterBCopy = deepClone(nextCluster);

                        tmpClusterACopy.individuals = tmpClusterACopy.individuals.concat(tmpClusterBCopy.individuals);

                        nextClusterIdx++;
                        nextCluster = tmpClusters[nextClusterIdx];
                    }
                }
                else if(curCluster[idKeyClusterData] != nextCluster[idKeyClusterData])
                {

                }

                dataDeduplicateObjectArray(tmpClusterACopy.individuals, idKeyRawData);

                idx = nextClusterIdx;
                nextClusterIdx = idx + 1;
            }

            output.dataClusters = tmpCombinedClusters;

            dataDeduplicateObjectArray(output.dataRaw, idKeyRawData);
            //dataDeduplicateObjectArray(output.dataClusters, idKeyClusterData);
            dataDeduplicateObjectArray(output.dataConsolidatedIndv, idKeyConsolidatedIndividuals);

            return output;
        }

        function dataDeduplicateObjectArray(data, dedupKey)
        {
            for(var idx in data)
            {
                var rowA = data[idx];
                var valA = rowA[dedupKey];

                for(var idxInner = Number.parseInt(idx) + 1; idxInner < data.length; idxInner++)
                {
                    var rowB = data[idxInner];
                    var valB = rowB[dedupKey];

                    while(valA == valB && idxInner < data.length)
                    {
                        data.splice(idxInner, 1);

                        if(idxInner < data.length)
                        {
                            rowB = data[idxInner];
                            valB = rowB[dedupKey];
                        }
                    }
                }
            }
        }
    </script>
</html>