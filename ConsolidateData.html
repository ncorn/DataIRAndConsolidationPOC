<html>
    <head>
        <style>
            .dataOutput{
                border-collapse: collapse;
                border: solid 1px #000000;
                margin-bottom: 20px;
            }

            #tblConsolIndv td{
                padding: 10px;
            }

            .rowHeader{
                border: solid 1px #000000;
            }

            .cellHeader{
                padding: 10px;
            }

            .cellData{
                padding: 10px;
            }

            .rowConsol{
                border: solid 1px #000000;
            }

            .cellConsol{
                padding: 10px;
            }
            
            .outContainer {
                margin-bottom: 20px;
            }

            .added{
                border: solid 3px #00ff00;
            }

            .removed{
                border: solid 3px #ff0000;
            }
        </style>

        <script lang="javascript">
            var scenarios = [];
            var defaultScenario = 4;

            var colors = [
                'ffdbd9',
                'ffeed9',
                'feffd9',
                'd9ffda',
                'd9feff',
                'dbd9ff',
                'f2d9ff',
                'ffd9f7',
                'ffd9da'
            ];
        </script>
        <script src="https://code.jquery.com/jquery-3.6.1.min.js" integrity="sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ=" crossorigin="anonymous"></script>
        
        <script src="Scenario-MultipleLeads.js"></script>
        <!--
        <script src="Scenario-MultipleContacts.js"></script>
        <script src="Scenario-MultipleEmails.js"></script>
        <script src="Scenario-SharedFamilyEmail.js"></script>
        <script src="Scenario-NameChange.js"></script>
        <script src="Scenario-EmailChange.js"></script>
        -->
        <script lang="javascript"></script>
    </head>
    <body>
        <div>
            <select id="selScenario">
                <option></option>
            </select>
            <select id="selDeltaView">
                <option value="merged" selected="true">Merged</option>
                <option value="start">Start</option>
                <option value="finish">Finish</option>
            </select>
        </div>
        <h1>Raw Individuals</h1>
        <div class="outContainer" id="outRawData"></div>
        <h1 style="display: none;">Match Key Sorted Individuals</h1>
        <div style="display: none;" class="outContainer" id="outSortedData"></div>
        <h1>Clustered Individuals</h1>
        <div class="outContainer" id="outGroupedData"></div>
        <h1>Consolidated Individuals</h1>
        <div class="outContainer" id="outConsolidatedData"></div>
    </body>
    <script lang="javascript">
        var currentScenario = scenarios[0];
        var currentView = 'merged';
        var scenarioDD = $('#selScenario');
        
        for(var idx in scenarios)
        {
            var curScenario = scenarios[idx];
            var curTitlte = curScenario.title ?? idx;

            scenarioDD.append('<option value="' + idx + '">' + curTitlte + '</option>');
        }
        
        scenarioDD.change(function()
        {
            clear();

            if(this.value != '')
            {
                currentScenario = scenarios[this.value];
                executePipeline(currentScenario, 0, 1, currentView /*'merged' 'start' 'finish'*/);
            }
        });

        var viewDD = $('#selDeltaView');

        viewDD.change(function(){
            currentView = this.value;

            clear();
            executePipeline(currentScenario, 0, 1, currentView /*'merged' 'start' 'finish'*/);
        });

        function clear(){
            var clearIDs = ['outRawData', 'outSortedData', 'outGroupedData', 'outConsolidatedData'];

            for(var idx in clearIDs)
            {
                $('#' + clearIDs[idx]).empty();
            }
        }

        function deepClone(obj){
            return JSON.parse(JSON.stringify(obj));
        }

        function dataCalculateDeltas(objGroupA, objGroupB, compareKey)
        {
            /*
            var idsA = indivGroupA.map(x => x[compareKey]);
            var idsB = indivGroupB.map(x => x[compareKey]);

            var idsARemoved = [];
            var idsAAdded = [];
            var idsAMatched = [];
            var idsBRemoved = [];
            var idsARemoved = [];
            var idsBMatched = [];
            */

            objGroupA.sort((a,b) => {
                var valA = a[compareKey];
                var valB = b[compareKey];

                if(valA > valB)
                {
                    return 1;
                }

                if(valB > valA)
                {
                    return -1;
                }

                return 0;
            });
            objGroupB.sort();

            var idxB = 0;
            var isFirstB = true;

            for(var idxA in objGroupA)
            {
                var objA = objGroupA[idxA];
                var curValA = objA[compareKey];

                var objMatched = false;

                if(idxB < objGroupB.length)
                {
                    var objB = objGroupB[idxB];
                    var curValB = objB[compareKey];

                    while(idxB < objGroupB.length && curValA >= curValB)
                    {
                        if(curValA == curValB)
                        {
                            objA.delta = 'unchanged';
                            objB.delta = 'unchanged';

                            objMatched = true;
                        }
                        else{
                            objB.delta = 'added';
                        }

                        //console.log(curValA + ' ' + curValB);

                        idxB++;

                        if(idxB < objGroupB.length)
                        {
                            objB = objGroupB[idxB];
                            curValB = objB[compareKey];
                        }
                    }
                }
                
                if(!objMatched)
                {
                    objA.delta = 'removed';
                }
            }
        }

        const hashString = function(str, seed = 0) {
            let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
            for (let i = 0, ch; i < str.length; i++) {
                ch = str.charCodeAt(i);
                h1 = Math.imul(h1 ^ ch, 2654435761);
                h2 = Math.imul(h2 ^ ch, 1597334677);
            }
            h1 = Math.imul(h1 ^ (h1>>>16), 2246822507) ^ Math.imul(h2 ^ (h2>>>13), 3266489909);
            h2 = Math.imul(h2 ^ (h2>>>16), 2246822507) ^ Math.imul(h1 ^ (h1>>>13), 3266489909);
            return 4294967296 * (2097151 & h2) + (h1>>>0);
        };

        function crteateDataFromScenarioRawData(data, irMatchKey){
            // get the raw data
            var stepRawData = deepClone(data);

            // get data sorted by match key
            var stepSortedData = deepClone(data);

            stepSortedData.sort(function(a,b){
                var valA = a[irMatchKey];
                var valB = b[irMatchKey];

                if(valA>valB)
                {
                    return 1;
                }

                if(valA<valB)
                {
                    return -1;
                }

                    return 0;
            });

            // cluster the data (IR)
            // break data apart by match key
            var clusters = [];
            var isFirst = true;
            var prevValue;
            var curCluster = {
                matchValue: null,
                clusterId: null,
                individuals: new Array()
            };
            
            clusters.push(curCluster);

            for(var idx in stepSortedData)
            {
                if(isFirst)
                {
                    prevValue = stepSortedData[idx][irMatchKey];
                    isFirst = false;
                }

                var curRow = deepClone(stepSortedData[idx]);
                var curValue = curRow[irMatchKey];
                var curClusterId = hashString(curValue);

                if(curValue !== prevValue)
                {
                    curCluster = {
                        matchValue: null,
                        clusterId: null,
                        individuals: new Array()
                    };
                    clusters.push(curCluster);
                }

                curCluster.matchValue = curValue;
                curCluster.clusterId = curClusterId;
                curCluster.individuals.push(curRow);

                var prevValue = curValue;
            }

            var consolidatedIndividuals = new Array();

            for(var idx in clusters)
            {
                var clst = clusters[idx];
                var curConsIndv = ConsolidateData(clst.individuals, 'Consolidate');

                clst.unifiedIndividualId = curConsIndv.id;

                consolidatedIndividuals.push(curConsIndv);
            }

            var output = {
                dataRaw: stepRawData,
                dataMatchSorted: stepSortedData,
                dataClusters: clusters,
                dataConsolidatedIndv: consolidatedIndividuals
            };

            return output;
        }

        function outputTablesForEachDataType(dataObj)
        {
            // Display the raw data
            outputTableFromObjectArray(dataObj.dataRaw, 'outRawData');
            outputTableFromObjectArray(dataObj.dataConsolidatedIndv, 'outConsolidatedData', true);

            for(var idx in dataObj.dataClusters)
            {
                var curCluster = dataObj.dataClusters[idx];
                var table = outputTableFromObjectArray(curCluster.individuals, 'outGroupedData', true);

                var clusterRow = $('<tr><td colspan="100">Unified Individual Id: ' + curCluster.unifiedIndividualId + ', Cluster ID: ' + curCluster.clusterId + ', Match Value: ' + curCluster.matchValue + ', Delta: ' + curCluster.delta + '</td></tr>');
                table.prepend(clusterRow);

                if(curCluster.delta == 'removed')
                {
                    table.addClass('removed');
                }

                if(curCluster.delta == 'added')
                {
                    table.addClass('added');
                }
            }
        }

        function output(curScenario)
        {
            return;
            // Display the raw data
            outputTableFromObjectArray(curScenario.data, 'outRawData');

            // sort data on match key
            //var sortedRawData = curScenario.data.map((x) => x);
            var sortedRawData = deepClone(curScenario.data);
            
            sortedRawData.sort(function(a,b){
                var valA = a[curScenario.matchKey];
                var valB = b[curScenario.matchKey];

                if(valA>valB)
                {
                    return 1;
                }

                if(valA<valB)
                {
                    return -1;
                }

                    return 0;
            });

            outputTableFromObjectArray(sortedRawData, 'outSortedData', false);

            // break data apart by match key
            var groupedRecoreds = [];
            var isFirst = true;
            var prevValue;
            var curGroup = new Array();
            groupedRecoreds.push(curGroup);

            for(var idx in sortedRawData)
            {
                if(isFirst)
                {
                    prevValue = sortedRawData[idx][curScenario.matchKey];
                    isFirst = false;
                }

                var curRow = sortedRawData[idx];
                var curValue = curRow[curScenario.matchKey];

                if(curValue !== prevValue)
                {
                    curGroup = new Array();
                    groupedRecoreds.push(curGroup);
                }

                curGroup.push(curRow);

                var prevValue = curValue;
            }

            var unifiedIndividuals = [];

            for(var idx in groupedRecoreds)
            {
                var data = groupedRecoreds[idx];

                data.sort(function(a,b){
                    var typeRanking = {
                        Contact: 0,
                        Lead: 1
                    };

                    var rankA = typeRanking[a.object_type];
                    var rankB = typeRanking[b.object_type];

                    if(rankA > rankB)
                    {
                        return 1;
                    }

                    if(rankA < rankB)
                    {
                        return -1;
                    }

                    if(rankA == rankB)
                    {
                        if(a.last_updated > b.last_updated)
                        {
                            return -1;
                        }

                        if(b.last_updated > a.last_updated)
                        {
                            return 1;
                        }
                    }

                    return 0;
                })

                var consolidated = ConsolidateData(data, 'Consolidate');
                unifiedIndividuals.push(consolidated);
                data.push(consolidated);

                outputTableFromObjectArray(data, 'outGroupedData', true);
            }

            outputTableFromObjectArray(unifiedIndividuals, 'outConsolidatedData', true);
        }

        function ConsolidateData(arrayData, mode)
        {
            var masterObj = getCompleteProperties(arrayData);
            var retObj = { colorMap: {}, isUnifiedIndv: true };

            if(mode == 'Consolidate')
            {
                // loop through each property
                for(var masterKey in masterObj)
                {
                    retObj[masterKey] = null;

                    // find the first available value
                    for(var idx in arrayData)
                    {
                        var curRow = arrayData[idx];
                        var curVal = curRow[masterKey];
                        var curColor = curRow.color;

                        if(curVal != undefined && curVal !=null)
                        {
                            retObj[masterKey] = curVal;
                            retObj.colorMap[masterKey] = curColor;
                            break;
                        }
                    }
                }
            }

            return retObj;
        }            

        function outputTableFromObjectArray(arrayData, outContainerID, append)
        {
            var outTable = $('<table class="dataOutput"></table>');
            var excludedKeys = [ 'color', 'colorMap', 'isUnifiedIndv' ];
            var data = arrayData;
            var masterObj = getCompleteProperties(arrayData);

            var outContainer = $('#' + outContainerID);

            if(!append)
            {
                outContainer.empty();
            }

            outContainer.append(outTable);

            // collect all properties
            for(var i = 0; i < data.length; i++)
            {
                var curObj = data[i];


                for(var key in curObj)
                {
                    if(masterObj[key] === undefined || masterObj[key] == null)
                    {
                        masterObj[key] = [];
                    }

                    var curVal = curObj[key];
                    var curColor = curObj.color;

                    if(curVal !== undefined && curVal !== null)
                    {
                        masterObj[key].push({ color: curColor, val: curVal });
                    }
                }
            }

            // output the headers
            var rowHeader = $('<tr class="rowHeader"></tr>');// outputTable.append('<th></th>');
            outTable.append(rowHeader);
            rowHeader.append('<th class="cellHeader">Rank</th>');

            for(var masterKey in masterObj)
            {
                if(!excludedKeys.includes(masterKey))
                {
                    //console.log('MK: ' + masterKey);
                    var col = rowHeader.append('<th class="cellHeader">' + masterKey + '</th>');
                }
            }

            // output data
            for(var dataKey in data)
            {
                var curData = data[dataKey];
                var curColor = curData.color;
                var rank = dataKey;

                var row = $('<tr></tr>');

                if(curData.isUnifiedIndv)
                {
                    row.addClass('rowConsol');
                    rank = '';
                }

                if(curData.delta == 'added')
                {
                    row.addClass('added');
                }

                if(curData.delta == 'removed')
                {
                    row.addClass('removed');
                }

                outTable.append(row);
                row.append('<td class="cellData" style="background-color: #' + curColor + '">' + rank + '</td>');

                for(var masterKey in masterObj)
                {
                    if(!excludedKeys.includes(masterKey))
                    {
                        var curVal = curData[masterKey];

                        if(curVal === undefined)
                        {
                            curColor = 'efefef';
                        }

                        if(curData.colorMap)
                        {
                            curColor = curData.colorMap[masterKey] ?? curColor;
                        }

                        //console.log(key);
                        //console.log(curVal);

                        if(Array.isArray(curVal))
                        {
                            var list = $('<td class="cellData" style="background-color: #' + curColor + '"><ul></ul></td>');


                            for(var idx in curVal)
                            {
                                var curItem = curVal[idx]

                                if(typeof curItem === 'object')
                                {
                                    curItem = JSON.stringify(curItem);
                                }

                                list.append('<li>' + curItem + '</li>');
                            }

                            row.append(list);
                        }
                        else
                        {
                            var col = row.append('<td class="cellData" style="background-color: #' + curColor + '">' + curVal + '</td>');
                        }
                    }
                }
            }

            return outTable;
        }

        function getCompleteProperties(arrayData)
        {
            var masterObj = {};
            data = arrayData;

            // collect all properties
            for(var i = 0; i < data.length; i++)
            {
                var curObj = data[i];

                for(var key in curObj)
                {
                    if(masterObj[key] === undefined)
                    {
                        masterObj[key] = null;
                    }
                }
            }

            return masterObj;
        }

        output(scenarios[defaultScenario]);
        
        var testScenario = scenarios[3];

        function executePipeline(scenario, startStepIdx, finishStepIdx, outputStep)
        {
            var matchKey = scenario.matchKey;
            var inputDataStart = scenario.data[startStepIdx];
            var inputDataFinish = scenario.data[finishStepIdx];

            var idKeyRaw = 'id';
            var idKeyClust = 'unifiedIndividualId';
            //var idKeyClust = 'clusterId';
            var idKeyConsIndv = 'id';
            //var idKeyConsIndv = idKeyClust;

            // compute all the data - cluster data, consolidate data
            var computedDataStart = crteateDataFromScenarioRawData(inputDataStart, matchKey);
            var computedDataFinish = crteateDataFromScenarioRawData(inputDataFinish, matchKey);

            dataCalculateDeltas(computedDataStart.dataRaw, computedDataFinish.dataRaw, idKeyRaw);
            dataCalculateDeltas(computedDataStart.dataClusters, computedDataFinish.dataClusters, idKeyClust)
            dataCalculateDeltas(computedDataStart.dataConsolidatedIndv, computedDataFinish.dataConsolidatedIndv, idKeyConsIndv);

            // calculate deltas for each individual cluster
            for(var idxA in computedDataStart.dataClusters)
            {
                var curClusterA = computedDataStart.dataClusters[idxA];
                var curClusterAId = curClusterA[idKeyClust];
                var clusterAMatched = false;

                for(var idxB in computedDataFinish.dataClusters)
                {
                    var curClusterB = computedDataFinish.dataClusters[idxB];
                    var curClusterBId = curClusterB[idKeyClust];

                    if(curClusterAId == curClusterBId)
                    {
                        clusterAMatched = true;
                        dataCalculateDeltas(curClusterA.individuals, curClusterB.individuals, idKeyRaw);
                    }
                }

                if(!clusterAMatched)
                {
                    for(var removedIdx in curClusterA.individuals)
                    {
                        curClusterA.individuals[removedIdx].delta = 'removed';
                    }
                }
            }

            for(var idx in computedDataFinish.dataClusters)
            {
                var curClusterFinished = computedDataFinish.dataClusters[idx];

                if(curClusterFinished.delta == 'added')
                {
                    for(var addIdx in curClusterFinished.individuals)
                    {
                        curClusterFinished.individuals[addIdx].delta = 'added';
                    } 
                }
            }

            var finalData = computedDataFinish;

            if(outputStep == 'start')
            {
                finalData = computedDataStart;
            }

            if(outputStep == 'merged')
            {
                finalData = dataCombineDataIterations(computedDataStart, computedDataFinish, idKeyRaw, idKeyClust, idKeyConsIndv);
            }

            outputTablesForEachDataType(finalData);
        }

        function dataCombineDataIterations(dataIterationOne, dataIterationTwo, idKeyRawData, idKeyClusterData, idKeyConsolidatedIndividuals)
        {
            var output = {
                dataRaw: deepClone(dataIterationOne.dataRaw),
                dataMatchSorted: deepClone(dataIterationOne.dataMatchSorted),
                dataClusters: deepClone(dataIterationOne.dataClusters),
                dataConsolidatedIndv: deepClone(dataIterationOne.dataConsolidatedIndv)
            };

            output.dataRaw = output.dataRaw.concat(deepClone(dataIterationTwo.dataRaw));
            output.dataMatchSorted = output.dataMatchSorted.concat(deepClone(dataIterationTwo.dataMatchSorted));
            output.dataConsolidatedIndv = output.dataConsolidatedIndv.concat(deepClone(dataIterationTwo.dataConsolidatedIndv));

            output.dataClusters = output.dataClusters.concat(deepClone(dataIterationTwo.dataClusters));

            var tmpClusters = deepClone(dataIterationOne.dataClusters);
            tmpClusters = tmpClusters.concat(deepClone(dataIterationTwo.dataClusters));

            dataSortObjectArrayByKey(tmpClusters, idKeyClusterData);

            // combine any duplicate clusters
            var tmpCombinedClusters = new Array();
            var idx = 0;
            var nextClusterIdx = idx + 1;

            while(idx < tmpClusters.length)
            {
                var curCluster = tmpClusters[idx];
                var nextCluster = tmpClusters[nextClusterIdx];
                var tmpClusterACopy = deepClone(curCluster);
                tmpCombinedClusters.push(tmpClusterACopy);

                if(nextCluster === undefined)
                {
                    
                }
                else if(curCluster[idKeyClusterData] == nextCluster[idKeyClusterData])
                {
                    while(nextCluster !== undefined && curCluster[idKeyClusterData] == nextCluster[idKeyClusterData])
                    {
                        var tmpClusterBCopy = deepClone(nextCluster);

                        tmpClusterACopy.individuals = tmpClusterACopy.individuals.concat(tmpClusterBCopy.individuals);

                        nextClusterIdx++;
                        nextCluster = tmpClusters[nextClusterIdx];
                    }
                }
                else if(curCluster[idKeyClusterData] != nextCluster[idKeyClusterData])
                {

                }

                dataDeduplicateObjectArray(tmpClusterACopy.individuals, idKeyRawData);

                idx = nextClusterIdx;
                nextClusterIdx = idx + 1;
            }

            output.dataClusters = tmpCombinedClusters;

            dataDeduplicateObjectArray(output.dataRaw, idKeyRawData);
            //dataDeduplicateObjectArray(output.dataClusters, idKeyClusterData);
            dataDeduplicateObjectArray(output.dataConsolidatedIndv, idKeyConsolidatedIndividuals);

            return output;
        }

        function dataSortObjectArrayByKey(dataArray, sortKey)
        {
            dataArray.sort((a,b) => {
                var valA = a[sortKey];
                var valB = b[sortKey];

                if(valA>valB)
                {
                    return 1;
                }

                if(valA<valB)
                {
                    return -1;
                }

                return 0;
            })
        }

        function dataDeduplicateObjectArray(data, dedupKey)
        {
            for(var idx in data)
            {
                var rowA = data[idx];
                var valA = rowA[dedupKey];

                for(var idxInner = Number.parseInt(idx) + 1; idxInner < data.length; idxInner++)
                {
                    var rowB = data[idxInner];
                    var valB = rowB[dedupKey];

                    while(valA == valB && idxInner < data.length)
                    {
                        data.splice(idxInner, 1);

                        if(idxInner < data.length)
                        {
                            rowB = data[idxInner];
                            valB = rowB[dedupKey];
                        }
                    }
                }
            }
        }

        executePipeline(curScenario, 0, 1, currentView /*'merged' 'start' 'finish'*/);

        var test = 'test';
    </script>
</html>