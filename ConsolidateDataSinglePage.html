<html>
    <head>
        <style>
            .dataOutput{
                border-collapse: collapse;
                border: solid 1px #000000;
                margin-bottom: 20px;
                width: 800px;
            }

            #tblConsolIndv td{
                padding: 10px;
            }

            .rowClusterInfo td{
                padding: 10px;
            }

            .rowHeader{
                border: solid 1px #000000;
            }

            .cellHeader{
                padding: 10px;
            }

            .cellData{
                padding: 10px;
            }

            .rowConsol{
                border: solid 1px #000000;
            }

            .cellConsol{
                padding: 10px;
            }
            
            .outContainer {
                margin-bottom: 20px;
            }

            .added{
                border: solid 3px #00ff00;
            }

            .removed{
                border: solid 3px #ff0000;
            }
        </style>

        <script lang="javascript">
            var showDeltas = true;
            var scenarios = [];
            var defaultScenario = 0;

            var colors = [
                'ffdbd9',
                'ffeed9',
                'feffd9',
                'd9ffda',
                'd9feff',
                'dbd9ff',
                'f2d9ff',
                'ffd9f7',
                'ffd9da'
            ];
        </script>
        <script src="https://code.jquery.com/jquery-3.6.1.min.js" integrity="sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ=" crossorigin="anonymous"></script>
        
        <script src="Scenario-MultipleLeads.js"></script>
        <script src="Scenario-SharedFamilyEmail.js"></script>
        <script src="Scenario-MultipleContacts.js"></script>

        <!--
        
        <script src="Scenario-MultipleEmails.js"></script>
        <script src="Scenario-NameChange.js"></script>
        <script src="Scenario-EmailChange.js"></script>
        -->
        <script lang="javascript"></script>
    </head>
    <body>
        <div>
            <select id="selScenario">
                <option></option>
            </select>
            <select id="selDeltaView">
                <option value="merged" selected="true">Merged</option>
                <option value="start">Start</option>
                <option value="finish">Finish</option>
            </select>
            <select id="selStepStart"></select>
        </div>
        <h1>Raw Individuals</h1>
        <div class="outContainer" id="outRawData"></div>
        <h1 style="display: none;">Match Key Sorted Individuals</h1>
        <div style="display: none;" class="outContainer" id="outSortedData"></div>
        <h1>Clustered Individuals</h1>
        <div class="outContainer" id="outGroupedData"></div>
        <h1>Consolidated Individuals</h1>
        <div class="outContainer" id="outConsolidatedData"></div>
    </body>
    <script lang="javascript">
        var currentscenarioIdx = defaultScenario;
        var currentScenario = scenarios[currentscenarioIdx];
        var currentScenarioStartingStep = 0;
        var currentView = 'merged';
        var scenarioDD = $('#selScenario');
        
        for(var idx in scenarios)
        {
            var curScenario = scenarios[idx];
            var curTitlte = curScenario.title ?? idx;

            var option = $('<option value="' + idx + '">' + curTitlte + '</option>');
            scenarioDD.append(option);

            scenarioDD.val(currentscenarioIdx);
        }
        
        scenarioDD.change(function()
        {
            clear();

            if(this.value != '')
            {
                currentScenario = scenarios[this.value];
                populateStepDDByScenario(currentScenario);
                executePipeline(currentScenario, currentScenarioStartingStep, currentScenarioStartingStep + 1, currentView /*'merged' 'start' 'finish'*/);
            }
        });

        var viewDD = $('#selDeltaView');

        viewDD.change(function(){
            currentView = this.value;

            clear();
            executePipeline(currentScenario, currentScenarioStartingStep, currentScenarioStartingStep + 1, currentView /*'merged' 'start' 'finish'*/);
        });

        var stepDD = $('#selStepStart');

        stepDD.change(function(){
            currentScenarioStartingStep = Number.parseInt(this.value);

            clear();
            executePipeline(currentScenario, currentScenarioStartingStep, currentScenarioStartingStep + 1, currentView /*'merged' 'start' 'finish'*/);
        });

        function refresh()
        {
            populateStepDDByScenario(currentScenario);
            executePipeline(currentScenario, currentScenarioStartingStep, currentScenarioStartingStep + 1, currentView /*'merged' 'start' 'finish'*/);
        }

        function populateStepDDByScenario(scenario)
        {
            stepDD.empty();

            if(scenario.data.length <= 1)
            {
                stepDD.hide();
            }
            else
            {
                stepDD.show();

                for(var i = 0; i < scenario.data.length - 1; i++)
                {
                    stepDD.append('<option value="' + i + '">' + (i+1) + '</option>');
                }
            }
        }

        function clear(){
            var clearIDs = ['outRawData', 'outSortedData', 'outGroupedData', 'outConsolidatedData'];

            for(var idx in clearIDs)
            {
                $('#' + clearIDs[idx]).empty();
            }
        }

        function deepClone(obj){
            return JSON.parse(JSON.stringify(obj));
        }

        function dataCalculateDeltas(objGroupA, objGroupB, compareKey)
        {
            var sortConfig = [{ key: compareKey, direction: 'asc'}]

            dataSortObjArrayByKeys(objGroupA, sortConfig);
            dataSortObjArrayByKeys(objGroupB, sortConfig);

            var idxB = 0;
            var isFirstB = true;

            for(var idxA in objGroupA)
            {
                var objA = objGroupA[idxA];
                var curValA = objA[compareKey];

                var objMatched = false;

                if(idxB < objGroupB.length)
                {
                    var objB = objGroupB[idxB];
                    var curValB = objB[compareKey];

                    while(idxB < objGroupB.length && curValA >= curValB)
                    {
                        if(curValA == curValB)
                        {
                            objA.delta = 'unchanged';
                            objB.delta = 'unchanged';

                            objMatched = true;
                        }
                        else{
                            objB.delta = 'added';
                        }

                        idxB++;

                        if(idxB < objGroupB.length)
                        {
                            objB = objGroupB[idxB];
                            curValB = objB[compareKey];
                        }
                    }
                }
                
                if(!objMatched)
                {
                    objA.delta = 'removed';
                }
            }
        }

        function hashString(str, seed = 0) {
            let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
            for (let i = 0, ch; i < str.length; i++) {
                ch = str.charCodeAt(i);
                h1 = Math.imul(h1 ^ ch, 2654435761);
                h2 = Math.imul(h2 ^ ch, 1597334677);
            }
            h1 = Math.imul(h1 ^ (h1>>>16), 2246822507) ^ Math.imul(h2 ^ (h2>>>13), 3266489909);
            h2 = Math.imul(h2 ^ (h2>>>16), 2246822507) ^ Math.imul(h1 ^ (h1>>>13), 3266489909);
            return 4294967296 * (2097151 & h2) + (h1>>>0);
        };

        function crteateDataFromScenarioRawData(data, irMatchKey){
            // get the raw data
            var stepRawData = deepClone(data);

            // get data sorted by match key
            var stepSortedData = deepClone(data);

            stepSortedData.sort(function(a,b){
                var valA = a[irMatchKey];
                var valB = b[irMatchKey];

                if(valA>valB)
                {
                    return 1;
                }

                if(valA<valB)
                {
                    return -1;
                }

                    return 0;
            });

            // cluster the data (IR)
            // break data apart by match key
            var clusters = [];
            var isFirst = true;
            var prevValue;
            var curCluster = {
                matchValue: null,
                clusterId: null,
                individuals: new Array()
            };
            
            clusters.push(curCluster);

            for(var idx in stepSortedData)
            {
                if(isFirst)
                {
                    prevValue = stepSortedData[idx][irMatchKey];
                    isFirst = false;
                }

                var curRow = deepClone(stepSortedData[idx]);
                var curValue = curRow[irMatchKey];
                var curClusterId = hashString(curValue);

                if(curValue !== prevValue)
                {
                    curCluster = {
                        matchValue: null,
                        clusterId: null,
                        individuals: new Array()
                    };
                    clusters.push(curCluster);
                }

                curCluster.matchValue = curValue;
                curCluster.clusterId = curClusterId;
                curCluster.individuals.push(curRow);

                var prevValue = curValue;
            }

            var consolidatedIndividuals = new Array();

            for(var idx in clusters)
            {
                var clst = clusters[idx];
                var curConsIndv = ConsolidateData(clst.individuals, 'Consolidate');

                clst.unifiedIndividualId = curConsIndv.id;

                consolidatedIndividuals.push(curConsIndv);
            }

            var output = {
                dataRaw: stepRawData,
                dataMatchSorted: stepSortedData,
                dataClusters: clusters,
                dataConsolidatedIndv: consolidatedIndividuals
            };

            return output;
        }

        function outputTablesForEachDataType(dataObj)
        {
            // Display the raw data
            outputTableFromObjectArray(dataObj.dataRaw, 'outRawData');
            outputTableFromObjectArray(dataObj.dataConsolidatedIndv, 'outConsolidatedData', true, false);

            for(var idx in dataObj.dataClusters)
            {
                var curCluster = dataObj.dataClusters[idx];
                var table = outputTableFromObjectArray(curCluster.individuals, 'outGroupedData', true, true);

                var clusterRow = $('<tr class="rowClusterInfo"><td colspan="100"><b>Unified Individual Id:</b> ' + curCluster.unifiedIndividualId + ', <b>Cluster ID:</b> ' + curCluster.clusterId + ', <b>Match Value:</b> ' + curCluster.matchValue + ', <b>Delta:</b> ' + curCluster.delta + '</td></tr>');
                table.prepend(clusterRow);

                if(curCluster.delta == 'removed')
                {
                    table.addClass('removed');
                }

                if(curCluster.delta == 'added')
                {
                    table.addClass('added');
                }
            }
        }

        function ConsolidateData(arrayData, mode)
        {
            dataSortObjArrayByKeys(arrayData, [  { key: 'object_type', direction: 'asc'}, { key: 'last_updated', direction: 'desc'} ]);
            var masterObj = getCompleteProperties(arrayData);
            var retObj = { colorMap: {}, isUnifiedIndv: true };

            if(mode == 'Consolidate')
            {
                // loop through each property
                for(var masterKey in masterObj)
                {
                    retObj[masterKey] = null;

                    // find the first available value
                    for(var idx in arrayData)
                    {
                        var curRow = arrayData[idx];
                        var curVal = curRow[masterKey];
                        var curColor = curRow.color;

                        if(curVal != undefined && curVal !=null)
                        {
                            retObj[masterKey] = curVal;
                            retObj.colorMap[masterKey] = curColor;
                            break;
                        }
                    }
                }
            }

            return retObj;
        }

        function dataSortObjArrayByKeys(objArray, sortKeys)
        {
            objArray.sort(function(a, b)
            {
                var retSort = 0;

                for(var idx in sortKeys)
                {
                    var sortKey = sortKeys[idx].key;
                    var sortDir = sortKeys[idx].direction;

                    var curSortValA = a[sortKey];
                    var curSortValB = b[sortKey];

                    if(curSortValA < curSortValB)
                    {
                        retSort = -1;

                        if(sortDir == 'desc')
                        {
                            retSort = retSort * -1;
                        }

                        break;
                    }

                    if(curSortValA > curSortValB)
                    {
                        retSort = 1;

                        if(sortDir == 'desc')
                        {
                            retSort = retSort * -1;
                        }

                        break;
                    }
                }

                return retSort;
            });
        }   

        function outputTableFromObjectArray(arrayData, outContainerID, append, showRank)
        {
            var outTable = $('<table class="dataOutput"></table>');
            var excludedKeys = [ 'color', 'colorMap', 'isUnifiedIndv' ];

            if(!showDeltas)
            {
                excludedKeys.push('delta');
            }

            var data = arrayData;
            var masterObj = getCompleteProperties(arrayData);

            var outContainer = $('#' + outContainerID);

            if(!append)
            {
                outContainer.empty();
            }

            outContainer.append(outTable);

            // collect all properties
            for(var i = 0; i < data.length; i++)
            {
                var curObj = data[i];


                for(var key in curObj)
                {
                    if(masterObj[key] === undefined || masterObj[key] == null)
                    {
                        masterObj[key] = [];
                    }

                    var curVal = curObj[key];
                    var curColor = curObj.color;

                    if(curVal !== undefined && curVal !== null)
                    {
                        masterObj[key].push({ color: curColor, val: curVal });
                    }
                }
            }

            // output the headers
            var rowHeader = $('<tr class="rowHeader"></tr>');// outputTable.append('<th></th>');
            outTable.append(rowHeader);

            if(showRank)
            {
                rowHeader.append('<th class="cellHeader">Rank</th>');
            }

            for(var masterKey in masterObj)
            {
                if(!excludedKeys.includes(masterKey))
                {
                    var col = rowHeader.append('<th class="cellHeader">' + masterKey + '</th>');
                }
            }

            // output data
            for(var dataKey in data)
            {
                var curData = data[dataKey];
                var curColor = curData.color;
                var rank = dataKey;

                var row = $('<tr></tr>');

                if(curData.isUnifiedIndv)
                {
                    row.addClass('rowConsol');
                    rank = '';
                }

                if(curData.delta == 'added')
                {
                    row.addClass('added');
                }

                if(curData.delta == 'removed')
                {
                    row.addClass('removed');
                }

                outTable.append(row);

                if(showRank)
                {
                    row.append('<td class="cellData" style="background-color: #' + curColor + '">' + rank + '</td>');
                }

                for(var masterKey in masterObj)
                {
                    if(!excludedKeys.includes(masterKey))
                    {
                        var curVal = curData[masterKey];

                        if(curVal === undefined)
                        {
                            curColor = 'efefef';
                        }

                        if(curData.colorMap)
                        {
                            curColor = curData.colorMap[masterKey] ?? curColor;
                        }

                        if(Array.isArray(curVal))
                        {
                            var list = $('<td class="cellData" style="background-color: #' + curColor + '"><ul></ul></td>');


                            for(var idx in curVal)
                            {
                                var curItem = curVal[idx]

                                if(typeof curItem === 'object')
                                {
                                    curItem = JSON.stringify(curItem);
                                }

                                list.append('<li>' + curItem + '</li>');
                            }

                            row.append(list);
                        }
                        else
                        {
                            var col = row.append('<td class="cellData" style="background-color: #' + curColor + '">' + curVal + '</td>');
                        }
                    }
                }
            }

            return outTable;
        }

        function getCompleteProperties(arrayData)
        {
            var masterObj = {};
            data = arrayData;

            // collect all properties
            for(var i = 0; i < data.length; i++)
            {
                var curObj = data[i];

                for(var key in curObj)
                {
                    if(masterObj[key] === undefined)
                    {
                        masterObj[key] = null;
                    }
                }
            }

            return masterObj;
        }

        function executePipeline(scenario, startStepIdx, finishStepIdx, outputStep)
        {
            var matchKey = scenario.matchKey;
            var inputDataStart = scenario.data[startStepIdx];
            var inputDataFinish = scenario.data[finishStepIdx];

            var idKeyRaw = 'id';
            var idKeyClust = 'unifiedIndividualId';
            //var idKeyClust = 'clusterId';
            var idKeyConsIndv = 'id';
            //var idKeyConsIndv = idKeyClust;

            // compute all the data - cluster data, consolidate data
            var computedDataStart = crteateDataFromScenarioRawData(inputDataStart, matchKey);
            var finalData = computedDataStart;

            if(scenario.data.length > 1)
            {
                var computedDataFinish = crteateDataFromScenarioRawData(inputDataFinish, matchKey);

                dataCalculateDeltas(computedDataStart.dataRaw, computedDataFinish.dataRaw, idKeyRaw);
                dataCalculateDeltas(computedDataStart.dataClusters, computedDataFinish.dataClusters, idKeyClust)
                dataCalculateDeltas(computedDataStart.dataConsolidatedIndv, computedDataFinish.dataConsolidatedIndv, idKeyConsIndv);

                // calculate deltas for each individual cluster
                for(var idxA in computedDataStart.dataClusters)
                {
                    var curClusterA = computedDataStart.dataClusters[idxA];
                    var curClusterAId = curClusterA[idKeyClust];
                    var clusterAMatched = false;

                    for(var idxB in computedDataFinish.dataClusters)
                    {
                        var curClusterB = computedDataFinish.dataClusters[idxB];
                        var curClusterBId = curClusterB[idKeyClust];

                        if(curClusterAId == curClusterBId)
                        {
                            clusterAMatched = true;
                            dataCalculateDeltas(curClusterA.individuals, curClusterB.individuals, idKeyRaw);
                            clusterAMatched = true;
                        }
                    }

                    if(!clusterAMatched)
                    {
                        for(var removedIdx in curClusterA.individuals)
                        {
                            curClusterA.individuals[removedIdx].delta = 'removed';
                        }
                    }
                }

                for(var idx in computedDataFinish.dataClusters)
                {
                    var curClusterFinished = computedDataFinish.dataClusters[idx];

                    if(curClusterFinished.delta == 'added')
                    {
                        for(var addIdx in curClusterFinished.individuals)
                        {
                            curClusterFinished.individuals[addIdx].delta = 'added';
                        } 
                    }
                }

                finalData = computedDataFinish;

                if(outputStep == 'start')
                {
                    finalData = computedDataStart;
                }

                if(outputStep == 'merged')
                {
                    finalData = dataCombineDataIterations(computedDataStart, computedDataFinish, idKeyRaw, idKeyClust, idKeyConsIndv);
                }
            }

            outputTablesForEachDataType(finalData);
        }

        function dataCombineDataIterations(dataIterationOne, dataIterationTwo, idKeyRawData, idKeyClusterData, idKeyConsolidatedIndividuals)
        {
            var output = {
                dataRaw: deepClone(dataIterationOne.dataRaw),
                dataMatchSorted: deepClone(dataIterationOne.dataMatchSorted),
                dataClusters: deepClone(dataIterationOne.dataClusters),
                dataConsolidatedIndv: deepClone(dataIterationOne.dataConsolidatedIndv)
            };

            output.dataRaw = output.dataRaw.concat(deepClone(dataIterationTwo.dataRaw));
            output.dataMatchSorted = output.dataMatchSorted.concat(deepClone(dataIterationTwo.dataMatchSorted));
            output.dataConsolidatedIndv = output.dataConsolidatedIndv.concat(deepClone(dataIterationTwo.dataConsolidatedIndv));

            output.dataClusters = output.dataClusters.concat(deepClone(dataIterationTwo.dataClusters));

            var tmpClusters = deepClone(dataIterationOne.dataClusters);
            tmpClusters = tmpClusters.concat(deepClone(dataIterationTwo.dataClusters));

            dataSortObjArrayByKeys(tmpClusters, [{key: idKeyClusterData, direction: 'asc'}]);

            // combine any duplicate clusters
            var tmpCombinedClusters = new Array();
            var idx = 0;
            var nextClusterIdx = idx + 1;

            while(idx < tmpClusters.length)
            {
                var curCluster = tmpClusters[idx];
                var nextCluster = tmpClusters[nextClusterIdx];
                var tmpClusterACopy = deepClone(curCluster);
                tmpCombinedClusters.push(tmpClusterACopy);

                if(nextCluster === undefined)
                {
                    
                }
                else if(curCluster[idKeyClusterData] == nextCluster[idKeyClusterData])
                {
                    while(nextCluster !== undefined && curCluster[idKeyClusterData] == nextCluster[idKeyClusterData])
                    {
                        var tmpClusterBCopy = deepClone(nextCluster);

                        tmpClusterACopy.individuals = tmpClusterACopy.individuals.concat(tmpClusterBCopy.individuals);

                        nextClusterIdx++;
                        nextCluster = tmpClusters[nextClusterIdx];
                    }
                }
                else if(curCluster[idKeyClusterData] != nextCluster[idKeyClusterData])
                {

                }

                dataDeduplicateObjectArray(tmpClusterACopy.individuals, idKeyRawData);

                idx = nextClusterIdx;
                nextClusterIdx = idx + 1;
            }

            output.dataClusters = tmpCombinedClusters;

            dataDeduplicateObjectArray(output.dataRaw, idKeyRawData);
            //dataDeduplicateObjectArray(output.dataClusters, idKeyClusterData);
            dataDeduplicateObjectArray(output.dataConsolidatedIndv, idKeyConsolidatedIndividuals);

            return output;
        }

        function dataDeduplicateObjectArray(data, dedupKey)
        {
            for(var idx in data)
            {
                var rowA = data[idx];
                var valA = rowA[dedupKey];

                for(var idxInner = Number.parseInt(idx) + 1; idxInner < data.length; idxInner++)
                {
                    var rowB = data[idxInner];
                    var valB = rowB[dedupKey];

                    while(valA == valB && idxInner < data.length)
                    {
                        data.splice(idxInner, 1);

                        if(idxInner < data.length)
                        {
                            rowB = data[idxInner];
                            valB = rowB[dedupKey];
                        }
                    }
                }
            }
        }

        refresh();
    </script>

    <script lang="javascript">
        var scen100 = {
            title: 'Multiple Leads',
            mode: 'Consoidate',
            matchKey: 'Email',
            data: 
            [
                [
                    //{ color: 'ffd9f7', object_type: 'Contact', id: 'C1', FirstName: 'Nathan', LastName: 'Smith', Email: 'personal@nsmith.com', last_updated: '2022-10-01' },

                    { color: 'fffead', object_type: 'Lead', id: 'L1', FirstName: 'Nathan', LastName: 'Smith', Email: 'personal@nsmith.com', last_updated: '2022-10-01' },
                    { color: 'ccffcf', object_type: 'Lead', id: 'L2', FirstName: 'Nathan', LastName: 'Smith', Email: 'personal@nsmith.com', last_updated: '2022-10-02' },

                    { color: 'cccfff', object_type: 'Lead', id: 'L3', FirstName: 'Nathan', LastName: 'Smith', Email: 'business@nsmith.com', last_updated: '2022-10-03' },
                    { color: 'ffcccc', object_type: 'Lead', id: 'L4', FirstName: 'Nathan', LastName: 'Smith', Email: 'business@nsmith.com', last_updated: '2022-10-04' },
                ],
                [
                    { color: 'ffd9f7', object_type: 'Contact', id: 'C1', FirstName: 'Nathan', LastName: 'Smith', Email: 'personal@nsmith.com', last_updated: '2022-10-05' },
            
                    { color: 'fffead', object_type: 'Lead', id: 'L1', FirstName: 'Nathan', LastName: 'Smith', Email: 'personal@nsmith.com', last_updated: '2022-10-01' },
                    { color: 'ccffcf', object_type: 'Lead', id: 'L2', FirstName: 'Nathan', LastName: 'Smith', Email: 'personal@nsmith.com', last_updated: '2022-10-02' },
            
                    { color: 'cccfff', object_type: 'Lead', id: 'L3', FirstName: 'Nathan', LastName: 'Smith', Email: 'business@nsmith.com', last_updated: '2022-10-03' },
                    { color: 'ffcccc', object_type: 'Lead', id: 'L4', FirstName: 'Nathan', LastName: 'Smith', Email: 'business@nsmith.com', last_updated: '2022-10-04' },
                ],
                [
                    { color: 'ffd9f7', object_type: 'Contact', id: 'C1', FirstName: 'Nathan', LastName: 'Smith', Email: 'business@nsmith.com', last_updated: '2022-10-06' },
            
                    { color: 'fffead', object_type: 'Lead', id: 'L1', FirstName: 'Nathan', LastName: 'Smith', Email: 'personal@nsmith.com', last_updated: '2022-10-01' },
                    { color: 'ccffcf', object_type: 'Lead', id: 'L2', FirstName: 'Nathan', LastName: 'Smith', Email: 'personal@nsmith.com', last_updated: '2022-10-02' },
            
                    { color: 'cccfff', object_type: 'Lead', id: 'L3', FirstName: 'Nathan', LastName: 'Smith', Email: 'business@nsmith.com', last_updated: '2022-10-03' },
                    { color: 'ffcccc', object_type: 'Lead', id: 'L4', FirstName: 'Nathan', LastName: 'Smith', Email: 'business@nsmith.com', last_updated: '2022-10-04' },
                ]
            ]
        }

        scenarios.push(scen100);
    </script>
</html>